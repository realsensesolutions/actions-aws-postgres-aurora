name: 'AWS Aurora Serverless v2 PostgreSQL'
description: 'Provision Aurora Serverless v2 PostgreSQL cluster (0.5 ACU minimum)'
author: 'realsensesolutions'

branding:
  icon: 'database'
  color: 'orange'

inputs:
  name:
    description: 'Instance name'
    required: true
  action:
    description: 'Action: apply, destroy, plan'
    required: false
    default: 'apply'
  database_name:
    description: 'Database name'
    required: false
    default: 'appdb'
  deletion_protection_enabled:
    description: 'Enable deletion protection'
    required: false
    default: 'false'
  min_capacity:
    description: 'Minimum ACU (0.5-128)'
    required: false
    default: '0.5'
  max_capacity:
    description: 'Maximum ACU (0.5-128)'
    required: false
    default: '2'
  lock_timeout:
    description: 'Terraform lock timeout'
    required: false
    default: '5m'
  publicly_accessible:
    description: 'Make database publicly accessible (NOT recommended for production)'
    required: false
    default: 'false'

outputs:
  cluster_endpoint:
    description: 'Aurora cluster endpoint'
    value: ${{ steps.outputs.outputs.cluster_endpoint }}
  cluster_arn:
    description: 'Aurora cluster ARN'
    value: ${{ steps.outputs.outputs.cluster_arn }}
  cluster_id:
    description: 'Aurora cluster identifier'
    value: ${{ steps.outputs.outputs.cluster_id }}
  secret_arn:
    description: 'Secrets Manager ARN with credentials'
    value: ${{ steps.outputs.outputs.secret_arn }}
  database_name:
    description: 'Database name'
    value: ${{ steps.outputs.outputs.database_name }}
  master_username:
    description: 'Master username'
    value: ${{ steps.outputs.outputs.master_username }}
  port:
    description: 'Database port'
    value: ${{ steps.outputs.outputs.port }}
  security_group_id:
    description: 'Security group ID'
    value: ${{ steps.outputs.outputs.security_group_id }}
  connection_string:
    description: 'Connection string template'
    value: ${{ steps.outputs.outputs.connection_string }}

runs:
  using: 'composite'
  steps:
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_wrapper: false

    - name: Terraform Init
      shell: bash
      working-directory: ${{ github.action_path }}/terraform
      env:
        TF_VAR_instance: ${{ inputs.name }}
      run: |

        if [[ -n "${TF_BACKEND_s3}" ]]; then
          terraform init -input=false -reconfigure \
            -backend-config="bucket=${TF_BACKEND_s3}" \
            -backend-config="key=aurora/${TF_VAR_instance}/terraform.tfstate" \
            -backend-config="region=${{ inputs.aws_region }}" \
            -backend-config="dynamodb_table=${TF_BACKEND_dynamodb}"
        else
          cat > backend_override.tf <<'EOFBACKEND'
        terraform {
          backend "local" {
            path = "local.tfstate"
          }
        }
        EOFBACKEND
          terraform init -input=false -reconfigure
        fi

    - name: Terraform Plan
      if: inputs.action == 'apply' || inputs.action == 'plan'
      shell: bash
      working-directory: ${{ github.action_path }}/terraform
      env:
        TF_VAR_instance: ${{ inputs.name }}
        TF_VAR_database_name: ${{ inputs.database_name }}
        TF_VAR_min_capacity: ${{ inputs.min_capacity }}
        TF_VAR_max_capacity: ${{ inputs.max_capacity }}
        TF_VAR_deletion_protection: ${{ inputs.deletion_protection_enabled }}
        TF_VAR_publicly_accessible: ${{ inputs.publicly_accessible }}
      run: |
        terraform plan -input=false -lock-timeout=${{ inputs.lock_timeout }} -out=tfplan

    - name: Terraform Apply
      if: inputs.action == 'apply'
      shell: bash
      working-directory: ${{ github.action_path }}/terraform
      run: |
        terraform apply -input=false -lock-timeout=${{ inputs.lock_timeout }} -auto-approve tfplan

    - name: Terraform Destroy
      if: inputs.action == 'destroy'
      shell: bash
      working-directory: ${{ github.action_path }}/terraform
      env:
        TF_VAR_instance: ${{ inputs.name }}
        TF_VAR_database_name: ${{ inputs.database_name }}
        TF_VAR_min_capacity: ${{ inputs.min_capacity }}
        TF_VAR_max_capacity: ${{ inputs.max_capacity }}
        TF_VAR_deletion_protection: ${{ inputs.deletion_protection_enabled }}
        TF_VAR_publicly_accessible: ${{ inputs.publicly_accessible }}
      run: |
        terraform destroy -input=false -lock-timeout=${{ inputs.lock_timeout }} -auto-approve

    - name: Set Outputs
      id: outputs
      if: inputs.action == 'apply'
      shell: bash
      working-directory: ${{ github.action_path }}/terraform
      run: |
        echo "cluster_endpoint=$(terraform output -raw cluster_endpoint 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
        echo "cluster_arn=$(terraform output -raw cluster_arn 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
        echo "cluster_id=$(terraform output -raw cluster_id 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
        echo "secret_arn=$(terraform output -raw secret_arn 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
        echo "database_name=$(terraform output -raw database_name 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
        echo "master_username=$(terraform output -raw master_username 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
        echo "port=$(terraform output -raw port 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
        echo "security_group_id=$(terraform output -raw security_group_id 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
        echo "connection_string=$(terraform output -raw connection_string 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
